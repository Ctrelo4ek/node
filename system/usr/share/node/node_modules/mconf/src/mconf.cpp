#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <getopt.h>
#include <INIReader.h>

using namespace std;

void usage(int status) {
    FILE *stream = (status == EXIT_SUCCESS) ? stdout : stderr;

    fprintf(stream,
    "MMRL Config\n\n"
    "Usage: mconf [options]\n\n"
    "Options:\n"
    "  -s, --scope NAME        Specify scope\n"
    "  -k, --key NAME          Specify key\n"
    "  -d, --default NAME          Specify default value\n"
    "  -h, --help              Display this help message and exit\n\n");
    exit(status);
}

string mconf(const char* scope, const char* key, const char* def) {
   const char* conf_file = "/data/adb/mmrl/config.ini";

   /* Find MMRL Config File */
   FILE *file;
   if (!(file = fopen(conf_file, "r"))) {
      fclose(file);
      return def;
   } 

   INIReader reader(conf_file);

   if (reader.ParseError() != 0) {
      return def;
   }
    
   return reader.Get(scope, key, def);
}

int main(int argc, char* argv[]) {

   int c;
   struct option long_opts[] = {
      { "scope",     required_argument,  nullptr, 's' },
      { "key",       required_argument,  nullptr, 'k' },
      { "default",   required_argument,  nullptr, 'd' },
      { "help",      no_argument,        nullptr, 'h' },
      { nullptr, 0, nullptr, 0 },
   };


	const char* scope = NULL;
	const char* key = NULL;
	const char* def = "unknown";

   while ((c = getopt_long(argc, argv, "s:k:d:h", long_opts, nullptr)) != -1) {
      switch (c) {
         case 'h':
            usage(EXIT_SUCCESS);
         case 's':
            scope = optarg;
            break;
         case 'k':
            key = optarg;
            break;
         case 'd':
            def = optarg;
            break;
         default:
            usage(EXIT_SUCCESS);
        }
   }
   
   cout << mconf(scope, key, def) << endl;

   return EXIT_SUCCESS;
}

#if __has_include(<napi.h>)
#include <napi.h>

using namespace Napi;

Value Add(const CallbackInfo& info) {
  Env env = info.Env();

  if (info.Length() < 2) {
    TypeError::New(env, "Wrong number of arguments").ThrowAsJavaScriptException();
    return env.Null();
  }

  if (!info[0].IsString() || !info[1].IsString() || !info[2].IsString()) {
    TypeError::New(env, "Wrong arguments").ThrowAsJavaScriptException();
    return env.Null();
  }

  string scope = info[0].As<String>();
  string key = info[1].As<String>();
  string def = info[2].As<String>();

  return String::New(env, mconf(scope.c_str(), key.c_str(), def.c_str()));
}

Object Init(Env env, Object exports) {
  exports.Set(String::New(env, "mconf"), Function::New(env, Add));
  return exports;
}

NODE_API_MODULE(addon, Init)

#endif
